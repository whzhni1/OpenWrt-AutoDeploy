name: æ‰“åŒ… OpenWrt è½¯ä»¶åŒ…

on:
  workflow_dispatch:
    inputs:
      projects:
        description: 'æŒ‡å®šé¡¹ç›®ï¼ˆé€—å·åˆ†éš”ï¼Œç•™ç©ºå…¨éƒ¨ï¼‰'
        required: false
      force:
        description: 'å¼ºåˆ¶é‡æ–°æ‰“åŒ…'
        type: boolean
        default: false
      fix_path:
        description: 'ä¿®æ”¹é»˜è®¤è·¯å¾„è‡³config'
        type: boolean
        default: true
  schedule:
    - cron: '0 2 * * *'

env:
  CONFIG_FILE: config/dabao_config.yaml

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.result }}
    steps:
      - uses: actions/checkout@v4
      
      - name: ç”ŸæˆçŸ©é˜µ
        id: matrix
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_PROJECTS: ${{ inputs.projects }}
          FORCE_BUILD: ${{ inputs.force }}
        run: |
          chmod +x .github/workflows/scripts/*.sh
          
          PROJECTS=$(yq e '.projects | keys | .[]' "$CONFIG_FILE")
          
          if [ -n "$INPUT_PROJECTS" ]; then
            FILTER_PATTERN=$(echo "$INPUT_PROJECTS" | tr ',' '|')
            PROJECTS=$(echo "$PROJECTS" | grep -E "^($FILTER_PATTERN)$" || true)
          fi
          
          MATRIX="["
          first=true
          
          for proj in $PROJECTS; do
            REPO=$(yq e ".projects.$proj.repo" "$CONFIG_FILE")
            FILTER=$(yq e ".projects.$proj.filter // \"\"" "$CONFIG_FILE")
            
            LATEST=$(gh api repos/$REPO/releases/latest --jq '.tag_name' 2>/dev/null || echo "")
            [ -z "$LATEST" ] && continue
            
            CURRENT=$(.github/workflows/scripts/version-manager.sh read "$proj" 2>/dev/null || echo "")
            
            if [ "$FORCE_BUILD" != "true" ] && [ "${LATEST#v}" = "${CURRENT#v}" ]; then
              echo "â­ï¸ $proj å·²æœ€æ–° $CURRENT"
              continue
            fi
            
            if [ -n "$FILTER" ]; then
              TYPE="bin"
            elif gh api "repos/$REPO/contents" --jq '.[].name' 2>/dev/null | grep -q 'go.mod'; then
              TYPE="go"
            elif gh api "repos/$REPO/contents" --jq '.[].name' 2>/dev/null | grep -q 'Cargo.toml'; then
              TYPE="rust"
            else
              TYPE="bin"
            fi
            
            echo "âœ… $proj: $CURRENT â†’ $LATEST ($TYPE)"
            
            [ "$first" = "true" ] && first=false || MATRIX="$MATRIX,"
            MATRIX="$MATRIX{\"project\":\"$proj\",\"version\":\"$LATEST\",\"type\":\"$TYPE\"}"
          done
          
          MATRIX="$MATRIX]"
          echo "result=$MATRIX" >> $GITHUB_OUTPUT
          echo "ğŸ“‹ çŸ©é˜µ: $MATRIX"

  build:
    needs: prepare
    if: needs.prepare.outputs.matrix != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        include: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    
    steps:
      - uses: actions/checkout@v4

      - name: å®‰è£…ä¾èµ–
        run: |
          sudo apt-get update
          sudo apt-get install -y upx-ucl
          
          # zig
          wget -q https://ziglang.org/download/0.11.0/zig-linux-x86_64-0.11.0.tar.xz
          tar xf zig-linux-x86_64-0.11.0.tar.xz
          sudo mv zig-linux-x86_64-0.11.0 /opt/zig
          echo "/opt/zig" >> $GITHUB_PATH
          
          # po2lmo
          git clone --depth 1 https://github.com/openwrt/luci.git /tmp/luci
          make -C /tmp/luci/modules/luci-base/src po2lmo
          sudo cp /tmp/luci/modules/luci-base/src/po2lmo /usr/local/bin/
          
          chmod +x .github/workflows/scripts/*.sh

      - name: å®‰è£… Go
        if: matrix.type == 'go'
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          cache: false

      - name: å®‰è£… Rust
        if: matrix.type == 'rust'
        run: |
          rustup target add \
            x86_64-unknown-linux-musl \
            aarch64-unknown-linux-musl \
            armv7-unknown-linux-musleabihf \
            arm-unknown-linux-musleabihf \
            i686-unknown-linux-musl

      - name: å¤„ç† ${{ matrix.project }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITCODE_TOKEN: ${{ secrets.GITCODE_TOKEN }}
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_ACCESS_KEY: ${{ secrets.R2_ACCESS_KEY }}
          R2_SECRET_KEY: ${{ secrets.R2_SECRET_KEY }}
          FIX_PATH: ${{ inputs.fix_path }}
        run: |
          proj="${{ matrix.project }}"
          LATEST="${{ matrix.version }}"
          TYPE="${{ matrix.type }}"
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ $proj $LATEST [$TYPE]"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          cfg() { yq e ".projects.$proj.$1 // \"\"" "$CONFIG_FILE"; }
          cfg_arr() { yq e ".projects.$proj.$1 // [] | .[]" "$CONFIG_FILE" | tr '\n' ' '; }
          cfg_def() { yq e ".projects.$proj.$1 // .defaults.$1 // \"$2\"" "$CONFIG_FILE"; }
          def() { yq e ".defaults.$1 // \"\"" "$CONFIG_FILE"; }
          
          REPO=$(cfg repo)
          LUCI_REPO=$(cfg luci_repo)
          
          mkdir -p downloads bins output
          
          # === Go ç¼–è¯‘ ===
          if [ "$TYPE" = "go" ]; then
            echo "ğŸ“¥ Clone $REPO@$LATEST"
            git clone --depth 1 --branch "$LATEST" "https://github.com/$REPO.git" source
            cd source
            
            # å‰ç«¯ï¼ˆä»… openlistï¼‰
            if [ "$proj" = "openlist" ]; then
              VER="${LATEST#v}"
              FRONTEND_URL="https://github.com/OpenListTeam/OpenList-Frontend/releases/download/v${VER}/openlist-frontend-dist-lite-v${VER}.tar.gz"
              echo "ğŸ“¥ å‰ç«¯: $FRONTEND_URL"
              curl -sL "$FRONTEND_URL" -o frontend.tar.gz
              mkdir -p public/dist && tar xzf frontend.tar.gz -C public/dist --strip-components=1
              rm frontend.tar.gz
              echo "ğŸ“‚ å‰ç«¯æ–‡ä»¶: $(find public/dist -type f | wc -l) ä¸ª"
            fi
            
            # æ¨¡å—å
            MODULE=$(grep '^module ' go.mod 2>/dev/null | awk '{print $2}')
            name=$(echo "$MODULE" | sed 's|/v[0-9]*$||' | xargs basename)
            [ -z "$name" ] && name="$proj"
            
            # å…¥å£ï¼ˆä¼˜å…ˆæ ¹ç›®å½• main.goï¼‰
            main="."
            if [ ! -f "./main.go" ] && [ -d "./cmd" ]; then
              main=$(find ./cmd -maxdepth 1 -type d -iname "$name" | head -1)
              [ -z "$main" ] && main=$(find ./cmd -maxdepth 2 -name "main.go" -exec dirname {} \; 2>/dev/null | head -1)
              [ -z "$main" ] && main="."
            fi
            
            # ç‰ˆæœ¬ä¿¡æ¯ï¼ˆä»¿ç…§ Makefile GO_PKG_LDFLAGSï¼‰
            BUILD_DATE=$(date '+%Y-%m-%d %H:%M:%S %z')
            GO_VERSION=$(go version | sed 's/go version //')
            GIT_COMMIT="workflow/$(echo $GITHUB_SHA | cut -c1-7)"
            
            LDFLAGS_BASE="-s -w"
            if [ "$proj" = "openlist" ]; then
              LDFLAGS_BASE="$LDFLAGS_BASE \
                -X '${MODULE}/internal/conf.BuiltAt=${BUILD_DATE}' \
                -X '${MODULE}/internal/conf.GoVersion=${GO_VERSION}' \
                -X '${MODULE}/internal/conf.GitAuthor=OpenList Contributors' \
                -X '${MODULE}/internal/conf.GitCommit=${GIT_COMMIT}' \
                -X '${MODULE}/internal/conf.Version=v${VER}' \
                -X '${MODULE}/internal/conf.WebVersion=v${VER}'"
            fi
            
            echo "ğŸ“Œ æ¨¡å—: $name, å…¥å£: $main"
            
            # æ¶æ„å®šä¹‰
            # CGO æ¶æ„ï¼ˆzig æ”¯æŒä¸”æµ®ç‚¹ ABI å…¼å®¹ï¼‰
            declare -A CGO_ARCHS=(
              ["x86_64-linux-musl:amd64"]=x86_64
              ["aarch64-linux-musl:arm64"]=aarch64
              ["arm-linux-musleabihf:arm:7"]=armv7
              ["i386-linux-musl:386"]=i386
            )
            
            # çº¯ Go æ¶æ„ï¼ˆæ—  CGOï¼‰
            declare -A PURE_ARCHS=(
              ["arm:6"]=armv6
              ["arm:5"]=armv5
              ["mips:softfloat"]=mips
              ["mipsle:softfloat"]=mipsel
              ["mips64"]=mips64
              ["mips64le"]=mips64el
            )
            
            # openlist éœ€è¦ CGOï¼Œåªç¼–è¯‘ CGO_ARCHS
            if [ "$proj" = "openlist" ]; then
              echo "ğŸ”§ openlist: CGO æ¨¡å¼ï¼Œç¼–è¯‘ä¸»æµæ¶æ„"
              
              for spec in "${!CGO_ARCHS[@]}"; do
                arch_name="${CGO_ARCHS[$spec]}"
                IFS=: read -r zig_target GOARCH GOARM_OR_MIPS <<< "$spec"
                
                pkg_name="${name}-linux-musl-${arch_name}"
                echo "ğŸ”¨ Go CGO: $pkg_name"
                mkdir -p "../bins/$pkg_name"
                
                export GOOS=linux GOARCH CGO_ENABLED=1
                export CC="zig cc -target $zig_target"
                export CXX="zig c++ -target $zig_target"
                unset GOARM GOMIPS
                
                [ "$GOARCH" = "arm" ] && export GOARM="${GOARM_OR_MIPS:-7}"
                
                LDFLAGS="$LDFLAGS_BASE -linkmode external -extldflags '-static'"
                
                # 32ä½æ’é™¤ lark é©±åŠ¨ï¼ˆä»¿ç…§ Makefileï¼‰
                BUILD_TAGS=""
                if [ "$GOARCH" != "amd64" ] && [ "$GOARCH" != "arm64" ]; then
                  # æ’é™¤ lark éœ€è¦ç”¨ build tags æˆ–è€…ç›´æ¥ä¸å¤„ç†
                  :
                fi
                
                go build -trimpath -tags "$BUILD_TAGS" -ldflags="$LDFLAGS" -o "../bins/$pkg_name/$name" "$main"
                ls -lh "../bins/$pkg_name/$name"
              done
              
            else
              # å…¶ä»–é¡¹ç›®ï¼šçº¯ Goï¼Œç¼–è¯‘æ‰€æœ‰æ¶æ„
              echo "ğŸ”§ çº¯ Go æ¨¡å¼ï¼Œç¼–è¯‘å…¨éƒ¨æ¶æ„"
              
              # CGO æ¶æ„
              for spec in "${!CGO_ARCHS[@]}"; do
                arch_name="${CGO_ARCHS[$spec]}"
                IFS=: read -r zig_target GOARCH GOARM_OR_MIPS <<< "$spec"
                
                pkg_name="${name}-linux-musl-${arch_name}"
                echo "ğŸ”¨ Go: $pkg_name"
                mkdir -p "../bins/$pkg_name"
                
                export GOOS=linux GOARCH CGO_ENABLED=0
                unset GOARM GOMIPS CC CXX
                
                [ "$GOARCH" = "arm" ] && export GOARM="${GOARM_OR_MIPS:-7}"
                
                go build -trimpath -ldflags="$LDFLAGS_BASE" -o "../bins/$pkg_name/$name" "$main"
                ls -lh "../bins/$pkg_name/$name"
              done
              
              # çº¯ Go æ¶æ„
              for spec in "${!PURE_ARCHS[@]}"; do
                arch_name="${PURE_ARCHS[$spec]}"
                IFS=: read -r GOARCH GOARM_OR_MIPS <<< "$spec"
                
                pkg_name="${name}-linux-musl-${arch_name}"
                echo "ğŸ”¨ Go: $pkg_name"
                mkdir -p "../bins/$pkg_name"
                
                export GOOS=linux GOARCH CGO_ENABLED=0
                unset GOARM GOMIPS CC CXX
                
                case "$GOARCH" in
                  arm) export GOARM="${GOARM_OR_MIPS:-7}" ;;
                  mips|mipsle) export GOMIPS="${GOARM_OR_MIPS:-softfloat}" ;;
                esac
                
                go build -trimpath -ldflags="$LDFLAGS_BASE" -o "../bins/$pkg_name/$name" "$main"
                ls -lh "../bins/$pkg_name/$name"
              done
            fi
            cd ..
          
          # === Rust ç¼–è¯‘ ===
          elif [ "$TYPE" = "rust" ]; then
            echo "ğŸ“¥ Clone $REPO@$LATEST"
            git clone --depth 1 --branch "$LATEST" "https://github.com/$REPO.git" source
            cd source
            
            name=$(grep -E '^name\s*=' Cargo.toml | head -1 | sed 's/.*=\s*"\(.*\)"/\1/')
            [ -z "$name" ] && name="$proj"
            
            echo "ğŸ“Œ æ¨¡å—: $name"
            
            declare -A RUST_ARCHS=(
              [x86_64-unknown-linux-musl]=x86_64
              [aarch64-unknown-linux-musl]=aarch64
              [armv7-unknown-linux-musleabihf]=armv7
              [arm-unknown-linux-musleabihf]=armv6
              [i686-unknown-linux-musl]=i386
            )
            
            for target in "${!RUST_ARCHS[@]}"; do
              arch="${RUST_ARCHS[$target]}"
              pkg_name="${name}-linux-musl-${arch}"
              echo "ğŸ”¨ Rust: $pkg_name ($target)"
              mkdir -p "../bins/$pkg_name"
              
              cargo build --release --target "$target"
              find "target/$target/release" -maxdepth 1 -type f -executable ! -name "*.so" -exec cp {} "../bins/$pkg_name/" \;
            done
            cd ..
          
          # === ä¸‹è½½äºŒè¿›åˆ¶ ===
          else
            FILTER=$(cfg filter)
            echo "ğŸ“¥ ä¸‹è½½äºŒè¿›åˆ¶"
            
            gh api repos/$REPO/releases/tags/$LATEST --jq '.assets[].browser_download_url' 2>/dev/null | while read url; do
              name=$(basename "$url")
              [ -n "$FILTER" ] && { case "$name" in $FILTER) ;; *) continue ;; esac; }
              
              skip=false
              for ex in $(cfg_arr exclude); do case "$name" in $ex) skip=true; break ;; esac; done
              [ "$skip" = "true" ] && continue
              
              echo "  â¬‡ï¸ $name"
              curl -sL "$url" -o "downloads/$name"
            done
            
            for f in downloads/*; do
              [ -f "$f" ] || continue
              tmp=$(mktemp -d)
              case "$f" in
                *.tar.gz|*.tgz) tar -xzf "$f" -C "$tmp" ;;
                *.tar.xz) tar -xJf "$f" -C "$tmp" ;;
                *.zip) unzip -q "$f" -d "$tmp" ;;
                *.gz) gunzip -c "$f" > "$tmp/$(basename "${f%.gz}")" ;;
                *) cp "$f" "$tmp/" ;;
              esac
              pkg_name=$(basename "$f" | sed 's/\.\(tar\.gz\|tgz\|tar\.xz\|zip\|gz\)$//')
              mkdir -p "bins/$pkg_name"
              find "$tmp" -type f -executable -exec cp {} "bins/$pkg_name/" \;
              rm -rf "$tmp"
            done
          fi
          
          echo "ğŸ“‚ åŒ…: $(ls bins 2>/dev/null | wc -l) ä¸ª"
          ls -lh bins/*/
          
          # === LuCI ===
          LUCI_DIR=""
          if [ -n "$LUCI_REPO" ]; then
            echo "ğŸ“¥ LuCI: $LUCI_REPO"
            git clone --depth 1 "https://github.com/$LUCI_REPO.git" luci-src
            LUCI_DIR="luci-src"
            
            if [ "${FIX_PATH:-true}" = "true" ]; then
              echo "ğŸ”§ ä¿®æ”¹è·¯å¾„: /etc/$proj â†’ /etc/config/${proj}_data"
              find "$LUCI_DIR" -type f | while read f; do
                file -b "$f" | grep -qi text && sed -i "s|/etc/$proj|/etc/config/${proj}_data|g" "$f" 2>/dev/null
              done
            fi
          fi
          
          # === æ‰“åŒ… ===
          export PKG_UPX="$(cfg_def upx true)"
          .github/workflows/scripts/dabao.sh "$proj" "$LATEST" bins "$LUCI_DIR"
          
          # === å‘å¸ƒ ===
          PROJ_NAME=$(cat output/.proj_name 2>/dev/null || echo "$proj")
          export REPO_NAME="$PROJ_NAME"
          export TAG_NAME="$LATEST"
          export DOWNLOAD_DIR="output"
          export PLATFORMS="$(cfg_def platforms "$(def platforms)")"
          export R2_PUBLIC_URL="$(def R2_PUBLIC_URL)"
          export USERNAME="$(def username)"
          .github/workflows/scripts/release.sh
          
          echo "âœ… $proj å®Œæˆ"

      - name: ä¿å­˜ç‰ˆæœ¬
        if: success()
        run: |
          proj="${{ matrix.project }}"
          .github/workflows/scripts/version-manager.sh write "$proj" "${{ matrix.version }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase || true
          git add config/version.txt
          git commit -m "ğŸ“¦ $proj â†’ ${{ matrix.version }}" || true
          git push || true
